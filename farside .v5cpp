{"mode":"Text","textContent":"///WHEN UPLOADING TO V5, MAKE SURE THIS FITS NEARSIDE OR FARSIDE\n//EDIT VAR BELOW\n// 1 = FARSIDE \n//-1 = NEARSIDE\n  int invert = 1;\n\n#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n\n\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\ncontroller Controller1 = controller(primary);\ndigital_out wings = digital_out(Brain.ThreeWirePort.H);\nbool holdit = true;\nmotor mR1 = motor(PORT3, ratio6_1, false);\n\nmotor mArmR = motor(PORT4, ratio18_1, true);\n\nmotor mR3 = motor(PORT6, ratio6_1, true);\n\nmotor mL3 = motor(PORT8, ratio6_1, false);\n\n\n\nmotor mL1 = motor(PORT9, ratio6_1, true);\n\nmotor mR2 = motor(PORT14, ratio6_1, false);\n\nmotor mL2 = motor(PORT18, ratio6_1, true);\n\nmotor mArmL = motor(PORT19, ratio18_1, false);\n\nmotor_group arm= motor_group(mArmL, mArmR);\nmotor_group mLeft = motor_group(mL1, mL2, mL3);\nmotor_group mRight = motor_group(mR1, mR2, mR3);\ninertial imu = inertial(PORT11);\nsmartdrive Drivetrain = smartdrive(mLeft, mRight, imu, 319.19, 255, 235, mm, .5*0.5714285714285714);\n//drivetrain Drivetrain = drivetrain(mLeft, mRight, 319.19, 255, 235, mm, .5*0.5714285714285714);\n\n\n// ----------------------------------------------------------------------------\n//                                                                            \n//    Project:                                               \n//    Author:\n//    Created:\n//    Configuration: VRC 2023-2024 Striker (Drivetrain 2-motor, No Gyro)\n//                   Intake Motor in Port 8\n//                   Arm Motor in Port 3\n//                   Controller        \n//                                                                            \n// ----------------------------------------------------------------------------\n\n// Include the V5 Library\n#include \"vex.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// Begin project code\n\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n  wait(1, seconds);\n\n}\n\n//passive arm for now. commented out all Arm motor stuff\nvoid runArm() {\n    //Arm.setPosition(Controller1.Axis2.position(),degrees);\n}\nvoid turnAround() {\n  Drivetrain.turnFor(left, 180, degrees);\n}\n\nvoid stop_hammer_time(){//cannot think of variable names rn\n    holdit = !holdit;\n    if(holdit == true){arm.setStopping(hold);}\n\n\\]021    else{arm.setStopping(coast);}\n    arm.stop();}\n\nvoid _90fwd(){\nif(arm.isSpinning()==false){\narm.setPosition(fmod(arm.position(degrees),360),degrees);\n}\narm.spinToPosition(arm.position(degrees)+90, degrees, false);\n}\n\nvoid _90rvs(){\nif(arm.isSpinning()==false){\narm.setPosition(fmod(arm.position(degrees),360),degrees);\n}\narm.spinToPosition(arm.position(degrees)-90, degrees, false);\n}\n\nvoid autonomous(void) {\n\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"autonomous code\");\n  \n  arm.setVelocity(5400,rpm);\n  arm.setStopping(hold);\n  arm.stop();\n  //_90fwd();\n  //_90rvs();\n  Drivetrain.setDriveVelocity(40, percent);\n  Drivetrain.setTurnVelocity(40, percent);\n  arm.spinFor(forward,45,degrees,false);\n  Drivetrain.driveFor(forward,10+3.24803,inches);\n  Drivetrain.stop();\n  wait(1,seconds);\\\n  Drivetrain.driveFor(reverse,3,inches);\n  wait(15,seconds);\n\n  Drivetrain.turnFor(right, invert*45, degrees);\n  Drivetrain.driveFor(forward,22.869756222+3.24803,inches);\n  Drivetrain.turnFor(left,invert*45,degrees);\n  Drivetrain.driveFor(forward,15.461+3.24803,inches);\n  _90fwd();\n  _90rvs();\n  //wait(1, seconds);\n  //arm.stop();\n  //Drivetrain.driveFor(reverse,4.059, inches);\n  //if(invert == 1){\n    Drivetrain.turnFor(right, 90,degrees);\n    Drivetrain.driveFor(forward, 38.23+3.24803, inches);\n    Drivetrain.turnFor(left, 90, degrees);\n    Drivetrain.driveFor(forward, 6.925+3.24803, inches);\n    //wings.set(true);\n    Drivetrain.turnFor(right, 45, degrees);\n    Drivetrain.turnFor(left, 45, degrees);\n    //wings.set(false);\n    Drivetrain.turnFor(right, 45, degrees);\n    Drivetrain.driveFor(forward, 8.3572, inches);\n    Drivetrain.turnFor(left, 34, degrees);\n    Drivetrain.driveFor(forward, 5.371, inches);\n    _90fwd();\n    _90rvs();\n    Drivetrain.turnFor(left, 56, degrees);\n    //wings.set(true);\n    Drivetrain.driveFor(forward, 27.46, inches);\n    turnAround();\n    Drivetrain.driveFor(forward, 6, inches);\n    _90fwd();\n    _90rvs();\n    Drivetrain.driveFor(forward, 7, inches);\n  //}\n  //else{\n\n  //}\n\n}\n\n\nvoid userControl(void) {\narm.setMaxTorque(65,percent);\nBrain.Screen.clearScreen();\nDrivetrain.stop();\ndouble armOut;\ndouble canPress = true;\n  while (true) {\n    Drivetrain.setDriveVelocity(100, percent);\n    Drivetrain.setTurnVelocity(100, percent);\n    arm.setVelocity(100,percent);\n    if (Controller1.ButtonL1.pressing()) {\n      //wings.set(true);\n    }\n    else{\n      //wings.set(false);\n    }\n    armOut=Controller1.Axis2.position()*0.12;\n    //Arm.spin(forward,armOut,volt);\n    if(Controller1.ButtonL1.pressing()){_90fwd();}//L1 and L2 turn 90 backwards/forwards 4 intake\n    else if(Controller1.ButtonL2.pressing()){_90rvs();}\n    else if(Controller1.ButtonR1.pressing()){arm.spin(forward,12,volt);}//R1 and R2 yeet it like the old program\n    else if(Controller1.ButtonR2.pressing()){arm.spin(forward,-12,volt);}\n    else if (Controller1.ButtonL2.pressing()){ arm.setPosition(fmod(arm.position(degrees),360),degrees);\n      arm.spinToPosition(45,degrees,false);\n    }\n    //stop_hammer_time();//swap between coast and hold stopping patterns\n    //arm.stop();\n    //canPress=false;\n  \n    else{arm.setStopping(hold); arm.stop();canPress=true;}\n    mLeft.spin(forward,Controller1.Axis3.position()*.12+Controller1.Axis1.position()*.75*.12, volt);\n    mRight.spin(forward,Controller1.Axis3.position()*.12-Controller1.Axis1.position()*.75*.12, volt);\n    //one-stick drive\n    //mLeft.spin(forward,Controller1.Axis3.position()*.12+Controller4.Axis1.position()*.75*.12, volt);\n    //mRight.spin(forward,Controller1.Axis3.position()*.12-Controller4.Axis1.position()*.75*.12, volt);\n  }\n}\n    \n  \n  \n\n\n\nint main() {\n  // create competition instance\n  competition Competition;\n\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n  \n}","textLanguage":"cpp","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.5","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}